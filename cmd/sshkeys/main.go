package main

import (
	"context"
	"crypto/md5"  //nolint: gosec // allow weak cryptographic primitive
	"crypto/sha1" //nolint: gosec // allow weak cryptographic primitive
	"encoding/json"
	"flag"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/Eun/sshkeys"
	"github.com/asaskevich/govalidator"
	"golang.org/x/crypto/ssh"
)

var formatOption string
var outputOption string
var timeoutOption string
var concurrentOption int

// generated by goreleaser.
var version string
var commit string
var date string

const (
	authorizedKeys  = 1
	fingerprintMD5  = 2
	fingerprintSHA1 = 3
)

const (
	outputConsole = 0
	outputJSON    = 1
)

func setupFlags() {
	flag.StringVar(&formatOption, "format", "authorized_keys", "")
	flag.StringVar(&formatOption, "f", "authorized_keys", "")
	flag.StringVar(&outputOption, "output", "", "")
	flag.StringVar(&outputOption, "o", "", "")
	flag.StringVar(&timeoutOption, "timeout", "60s", "")
	flag.StringVar(&timeoutOption, "t", "60s", "")
	flag.IntVar(&concurrentOption, "concurrent", 4, "") //nolint: gomnd // allow constant
	flag.IntVar(&concurrentOption, "c", 4, "")          //nolint: gomnd // allow constant
}

func printUsage() {
	fmt.Fprintf(os.Stderr, "Usage: %s [options] <host>\n", filepath.Base(os.Args[0]))
	fmt.Fprintln(os.Stderr, "Options:")
	fmt.Fprintln(os.Stderr, "    -format=authorized_keys       "+
		"Format to print the public keys, valid formats are: fingerprint, "+""+
		"fingerprint-sha1, sha1, fingerprint-legacy, fingerprint-md5, md5, authorized_keys, authorizedkeys, authorized")
	fmt.Fprintln(os.Stderr, "    -output=console               Output format, valid formats are: console, json")
	fmt.Fprintln(os.Stderr, "    -timeout=60s                  Connection timeout")
	fmt.Fprintln(os.Stderr, "    -concurrent=4                 Concurrent workers")
	fmt.Fprintln(os.Stderr, "")
	fmt.Fprintf(os.Stderr, "sshkeys %s %s %s https://github.com/Eun/sshkeys", version, commit, date)
}

func main() {
	setupFlags()
	flag.Usage = printUsage
	flag.Parse()
	args := flag.Args()
	if len(args) == 0 {
		printUsage()
		os.Exit(1)
	}

	host := strings.TrimSpace(args[0])

	format := parseFormat(formatOption)
	output := parseOutput(outputOption)

	timeout, err := time.ParseDuration(timeoutOption)
	if err != nil {
		fmt.Fprintf(os.Stderr, "'%s' is not a duration\n", timeoutOption)
		os.Exit(1)
	}

	internalHost := host

	if !govalidator.IsDialString(host) {
		if !govalidator.IsHost(host) {
			exitWithMessage(output, host, fmt.Sprintf("'%s' is not a valid hostname", host))
			return
		}
		internalHost = net.JoinHostPort(internalHost, "22")
	}

	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	keys, err := sshkeys.GetKeys(ctx, internalHost, concurrentOption, sshkeys.DefaultKeyAlgorithms()...)
	cancel()
	if err != nil {
		exitWithMessage(output, host, err.Error())
		return
	}

	printableKeys := make([]string, 0, len(keys))
	for _, key := range keys {
		printableKey := keyToString(key, format)
		addToResult := true
		for _, k := range printableKeys {
			if k == printableKey {
				addToResult = false
				break
			}
		}
		if !addToResult {
			continue
		}
		printableKeys = append(printableKeys, printableKey)
	}

	sort.Slice(printableKeys, func(i, j int) bool {
		return printableKeys[i] < printableKeys[j]
	})

	switch output {
	case outputJSON:
		err = json.NewEncoder(os.Stdout).Encode(struct {
			Host       string
			PublicKeys []string
		}{host, printableKeys})
		if err != nil {
			fmt.Fprintf(os.Stderr, "unable to encode json: %+v", err)
		}
	default:
		for i := 0; i < len(printableKeys); i++ {
			fmt.Println(printableKeys[i])
		}
	}
}

func exitWithMessage(output int, host, s string) {
	switch output {
	case outputJSON:
		err := json.NewEncoder(os.Stdout).Encode(struct {
			Host  string
			Error string
		}{host, s})
		if err != nil {
			fmt.Fprintf(os.Stderr, "unable to encode json: %+v", err)
		}
	default:
		fmt.Fprintln(os.Stderr, s)
	}
	os.Exit(1)
}

func sumToString(sum []byte) (s string) {
	for i := 0; i < len(sum); i++ {
		s += fmt.Sprintf("%02x", sum[i])
		if i < len(sum)-1 {
			s += ":"
		}
	}
	return s
}

func keyToString(key ssh.PublicKey, format int) string {
	switch format {
	case fingerprintMD5:
		sum := md5.Sum(key.Marshal()) //nolint: gosec // allow weak cryptographic primitive
		return sumToString(sum[:])
	case fingerprintSHA1:
		sum := sha1.Sum(key.Marshal()) //nolint: gosec // allow weak cryptographic primitive
		return sumToString(sum[:])
	// case authorized_keys:
	//	fallthrough
	default:
		return strings.TrimSpace(string(ssh.MarshalAuthorizedKey(key)))
	}
}

func parseFormat(format string) int {
	switch strings.ToLower(strings.TrimSpace(format)) {
	case "fingerprint", "sha1", "fingerprint-sha1":
		return fingerprintSHA1
	case "fingerprint-legacy", "md5", "fingerprint-md5":
		return fingerprintMD5
	case "authorized_keys", "authorizedkeys", "authorized", "4716", "rfc-4716", "rfc4716":
		return authorizedKeys
	default:
		return authorizedKeys
	}
}

func parseOutput(output string) int {
	switch strings.ToLower(strings.TrimSpace(output)) {
	case "json":
		return outputJSON
	// case "console":
	//	fallthrough
	default:
		return outputConsole
	}
}
