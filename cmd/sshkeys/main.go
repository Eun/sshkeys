package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"net"
	"os"
	"os/signal"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/Eun/sshkeys"
	"github.com/asaskevich/govalidator"
	"golang.org/x/crypto/ssh"
)

var algorithmOption string
var encodingOption string
var outputOption string
var timeoutOption string
var concurrentOption int

// generated by goreleaser.
var version string
var commit string
var date string

type fingerPrintAlgo uint8

const (
	authorizedKeys fingerPrintAlgo = iota
	fingerprintMD5
	fingerprintSHA1
	fingerprintSHA256
)

const (
	outputConsole = 0
	outputJSON    = 1
)

func setupFlags() {
	flag.StringVar(&algorithmOption, "algorithm", "authorized_keys", "")
	flag.StringVar(&algorithmOption, "a", "authorized_keys", "")
	flag.StringVar(&encodingOption, "encoding", "", "")
	flag.StringVar(&encodingOption, "e", "", "")
	flag.StringVar(&outputOption, "output", "", "")
	flag.StringVar(&outputOption, "o", "", "")
	flag.StringVar(&timeoutOption, "timeout", "60s", "")
	flag.StringVar(&timeoutOption, "t", "60s", "")
	flag.IntVar(&concurrentOption, "concurrent", 4, "") //nolint: gomnd // allow constant
	flag.IntVar(&concurrentOption, "c", 4, "")          //nolint: gomnd // allow constant
}

func printUsage() {
	fmt.Fprintf(os.Stderr, "Usage: %s [options] <host>\n", filepath.Base(os.Args[0]))
	fmt.Fprintln(os.Stderr, "Options:")
	fmt.Fprintln(os.Stderr, "    -a authorized_keys")
	fmt.Fprintln(os.Stderr, "    -algorithm=authorized_keys")
	fmt.Fprintln(os.Stderr, "       Algorithm to hash the public keys, valid algorithms are: "+
		"sha1, sha256, md5, authorized_keys")
	fmt.Fprintln(os.Stderr)
	fmt.Fprintln(os.Stderr, "    -e=")
	fmt.Fprintln(os.Stderr, "    -encoding=")
	fmt.Fprintln(os.Stderr, "       Encoding to encode the hashed keys, valid encodings are: "+
		"hex, base32, base64 (only used for algorithms sha1, sha256 and md5)")
	fmt.Fprintln(os.Stderr)
	fmt.Fprintln(os.Stderr, "    -o=console")
	fmt.Fprintln(os.Stderr, "    -output=console")
	fmt.Fprintln(os.Stderr, "       Output format, valid formats are: console, json")
	fmt.Fprintln(os.Stderr)
	fmt.Fprintln(os.Stderr, "    -c=4")
	fmt.Fprintln(os.Stderr, "    -concurrent=4")
	fmt.Fprintln(os.Stderr, "       Concurrent workers")
	fmt.Fprintln(os.Stderr)
	fmt.Fprintln(os.Stderr, "    -t=60s")
	fmt.Fprintln(os.Stderr, "    -timeout=60s")
	fmt.Fprintln(os.Stderr, "       Connection timeout")
	fmt.Fprintln(os.Stderr)
	fmt.Fprintln(os.Stderr)
	fmt.Fprintf(os.Stderr, "sshkeys %s %s %s https://github.com/Eun/sshkeys", version, commit, date)
}

func main() {
	os.Exit(run())
}
func run() int {
	setupFlags()
	flag.Usage = printUsage
	flag.Parse()
	args := flag.Args()
	if len(args) == 0 {
		printUsage()
		return 1
	}

	host := strings.TrimSpace(args[0])
	algorithm := parseAlgorithm(&algorithmOption)

	var encoding sshkeys.Encoding
	if algorithm != authorizedKeys {
		encoding = parseEncoding(&encodingOption)
	} else {
		encodingOption = ""
	}

	output := parseOutput(outputOption)

	timeout, err := time.ParseDuration(timeoutOption)
	if err != nil {
		fmt.Fprintf(os.Stderr, "'%s' is not a duration\n", timeoutOption)
		return 1
	}

	internalHost := host

	if !govalidator.IsDialString(host) {
		if !govalidator.IsHost(host) {
			return exitWithMessage(output, host, fmt.Sprintf("'%s' is not a valid hostname", host))
		}
		internalHost = net.JoinHostPort(internalHost, "22")
	}

	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
	keys, err := sshkeys.GetKeys(ctx, internalHost, concurrentOption, timeout, sshkeys.DefaultKeyAlgorithms()...)
	cancel()
	if err != nil {
		return exitWithMessage(output, host, err.Error())
	}

	printableKeys := make([]string, 0, len(keys))
	for _, key := range keys {
		printableKey, marshalErr := keyToString(key, algorithm, encoding)
		if marshalErr != nil {
			return exitWithMessage(output, host, marshalErr.Error())
		}
		addToResult := true
		for _, k := range printableKeys {
			if k == printableKey {
				addToResult = false
				break
			}
		}
		if !addToResult {
			continue
		}
		printableKeys = append(printableKeys, printableKey)
	}

	sort.Slice(printableKeys, func(i, j int) bool {
		return printableKeys[i] < printableKeys[j]
	})

	return exitWithSuccess(output, host, printableKeys)
}

func exitWithSuccess(output int, host string, printableKeys []string) int {
	switch output {
	case outputJSON:
		err := json.NewEncoder(os.Stdout).Encode(struct {
			Host       string
			Algorithm  string
			Encoding   string
			PublicKeys []string
		}{
			Host:       host,
			Algorithm:  algorithmOption,
			Encoding:   encodingOption,
			PublicKeys: printableKeys,
		})
		if err != nil {
			fmt.Fprintf(os.Stderr, "unable to encode json: %+v", err)
		}
	default:
		for i := 0; i < len(printableKeys); i++ {
			fmt.Println(printableKeys[i])
		}
	}
	return 0
}

func exitWithMessage(output int, host, s string) int {
	switch output {
	case outputJSON:
		err := json.NewEncoder(os.Stdout).Encode(struct {
			Host  string
			Error string
		}{
			Host:  host,
			Error: s,
		})
		if err != nil {
			fmt.Fprintf(os.Stderr, "unable to encode json: %+v", err)
		}
	default:
		fmt.Fprintln(os.Stderr, s)
	}
	return 1
}

func keyToString(key ssh.PublicKey, algorithm fingerPrintAlgo, encoding sshkeys.Encoding) (string, error) {
	switch algorithm {
	case fingerprintMD5:
		return sshkeys.FingerprintMD5(encoding, key)
	case fingerprintSHA1:
		return sshkeys.FingerprintSHA1(encoding, key)
	case fingerprintSHA256:
		return sshkeys.FingerprintSHA256(encoding, key)
	case authorizedKeys:
		fallthrough //nolint:gocritic // allow fallthrough
	default:
		return sshkeys.AuthorizedKey(key)
	}
}

func parseAlgorithm(s *string) fingerPrintAlgo {
	*s = strings.ToLower(strings.TrimSpace(*s))
	switch *s {
	case "md5":
		return fingerprintMD5
	case "sha1":
		return fingerprintSHA1
	case "sha256":
		return fingerprintSHA256
	case "authorized_keys":
		fallthrough //nolint:gocritic // allow fallthrough
	default:
		*s = "authorized_keys"
		return authorizedKeys
	}
}

func parseEncoding(s *string) sshkeys.Encoding {
	*s = strings.ToLower(strings.TrimSpace(*s))
	switch *s {
	case "base32":
		return sshkeys.Base32Encoding
	case "base64":
		return sshkeys.Base64Encoding
	case "hex":
		fallthrough //nolint:gocritic // allow fallthrough
	default:
		*s = "hex"
		return sshkeys.HexEncoding
	}
}

func parseOutput(output string) int {
	switch strings.ToLower(strings.TrimSpace(output)) {
	case "json":
		return outputJSON
	// case "console":
	//	fallthrough
	default:
		return outputConsole
	}
}
